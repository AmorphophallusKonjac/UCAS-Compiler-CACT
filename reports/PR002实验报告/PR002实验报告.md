[toc]

# 编译原理研讨课实验PR002实验报告

## 任务说明

1.熟悉ANTLR的安装和使用，了解ANTLR工具的作用和工作原理，搭建ANTLR环境并运行demo

2.根据CACT文法规范编写ANTLR文法文件，完成词法和语法分析功能，完善词法文法错误检查，实现一个简单的编译器前端，并通过测试样例

## 成员组成

汪铭煜

盛子轩

苑骏康

## 实验设计

### 设计思路

#### 1.设计编译器的⽬录结构

> /cact/src/
> SemanticAnalyzer.h
> SemanticAnalyzer.cpp: 语义分析器，负责进行语义的检查，并生成IR类
> symbolTable.h
> symbolTable.cpp:符号表的建立，将符号与构建的IRValue建立对应关系
>
> IR/:生成的IR类，并且调用这些类来打印出最终的IR代码

### 实验实现

整个实验大致可以分为四个部分：语义检查，IR类的生成，IR代码的生成，IR的解释执行

#### 1.语义检查

语义检查主要负责在遍历语法树的时候，根据要求的cact语言规范检查是否有语义错误，如强制类型转换，数组赋值不正确等等。同时在分析的过程中建立block，block的符号表，全局块，函数表等，方便后续添加IRValue进行IR类和代码的生成。

##### symbol中常量变量等类的大致继承关系

```
/***********符号表***********/
class SymbolInfo {
private:
    int line;//表示是第几行声明的变量，函数，或者块
    std::string name;
    IROperand *operand;

protected:
    IRValue* irValue;

	...

    SymbolInfo(const std::string &name, int line);

    ~SymbolInfo(){};
};

class initValue {
protected:
    std::vector<IRConstant*> initValueArray;

public:

    void setInitValue(std::string valueStr, DataType datatype){
        ...
    };

    void setZero(DataType datatype){
        ...
    }

    int getinitValueArraySize() {
        return initValueArray.size();
    }

    std::vector<IRConstant*> getInitValueArray() {//获得某个常量的初始值
        return initValueArray;
    };
};

/***********常量变量数组符号表***********/
class ConstVarArraySymbolInfo : public SymbolInfo, public initValue {
private:
    DataType dataType;
    int global = 0;//代表是否是全局变量

protected:
    IRValue* irinitializer;

public:
    ...

    void setirInitailizer(IRValue* irinitializer) { irinitializer = irinitializer; };
    IRValue* getirInitailizer() { return irinitializer; };

    ConstVarArraySymbolInfo(const std::string &name, int line, DataType dataType, int global);

    ~ConstVarArraySymbolInfo(){};
};


/***********常量符号表***********/
class ConstSymbolInfo : public ConstVarArraySymbolInfo {
public:
    ...

    void setIRValue();

    ConstSymbolInfo(const std::string &name, int line, DataType dataType, int global);

    ~ConstSymbolInfo(){};
};


/***********变量符号表***********/
class VarSymbolInfo : public ConstVarArraySymbolInfo {
public:
    ...

    void setIRValue(IRValue* irvalue) { irValue = irValue; };
    void setIRValue(IRValue::ValueTy vTy, unsigned SymbolCount=0, IRBasicBlock* parent=nullptr, IRValue* IRinitializer=nullptr, IRModule* irmodule=nullptr);

    VarSymbolInfo(const std::string &name, int line, DataType dataType, int global);

    ~VarSymbolInfo(){};
};


/***********常量数组符号表***********/
class ConstArraySymbolInfo : public ConstVarArraySymbolInfo {
private:
    std::vector<int> arraySize;
    int dimension;

public:
   ...

    void setIRValue(IRModule* irmodule=nullptr, unsigned SymbolCount=0, const std::string& FuncName="");

    ConstArraySymbolInfo(const std::string &name, int line, DataType dataType, int global,
                         const std::vector<int> arraySize, int dimension);

    ~ConstArraySymbolInfo(){};
};


/***********变量数组符号表***********/
class VarArraySymbolInfo : public ConstVarArraySymbolInfo {
private:
    std::vector<int> arraySize;
    int dimension;

public:
    ...

    void setIRValue(IRValue* irvalue) { irValue = irValue; };
    void setIRValue(IRValue::ValueTy vTy, unsigned SymbolCount=0, IRBasicBlock* parent=nullptr, IRValue* IRinitializer=nullptr, IRModule* irmodule=nullptr);

    VarArraySymbolInfo(const std::string &name, int line, DataType dataType, int global,
                       const std::vector<int> arraySize, int dimension);

    ~VarArraySymbolInfo(){};
};
```

在符号类中，分为变量，变量数组，常量，常量数组四个子类；

它们继承自ConstVarArraySymbolInfo类。ConstVarArraySymbolInfo父类有函数set/getInitliazer，因此每个子类都会在初始的时候通过该函数获得一个初值；

同时它们都继承自symbolInfo类，因此每个子类都会在类内部维护一个irValue变量，方便后面IR生成可以根据irValue类直接进行操作；每个子类的setIRValue函数不尽相同，因此不可在父类中进行多态处理

##### func符号以及blockinfo中的维护的symboltable，functable符号函数表

```
class FuncSymbolInfo : public SymbolInfo{
private:
    int stack_size = 0;//函数需要栈的大小
    DataType returnType;

    std::vector<SymbolInfo *> paramList;//所有的symbol,将来作为User的IRValue全放在里面
    std::vector<IRType *> IRParams;//IRFunctionType需要的
    std::vector<IRArgument *> IRArgs;//将来作为Value的IRValue全放在里面

    BlockInfo *baseblock;//函数的基本块
public:
	...  

    FuncSymbolInfo(const std::string &name, int line, DataType returnType);

    ~FuncSymbolInfo() {
        for (SymbolInfo *symbol: paramList) { delete symbol; };
    };
};

/***********BlockInfo与Globalblock,block是记录符号表，函数表，块表的基本单位***********/
//对于块而言，这里不再强调它的line
class BlockInfo {
protected:
    BlockInfo *parentBlock;
    FuncSymbolInfo *belongTo = nullptr;//块属于某一个函数

    SymbolTable symbolTable;
    BlockTable blockTable;
    bool returnsign = false;//认定这个块是否满足returnpath都能满足
    //FuncTable funcTable;
    //这里我认为对于一个块而言只需要考虑他的符号表和他的subblock，函数表,对于函数表我的想法是可以做一个全局的，

public:
    BlockInfo *getParentBlock() { return parentBlock; }
    bool getReturnSign() { return returnsign; };
    void setReturnSign(bool returnSign) { returnsign = returnSign; }

    SymbolInfo *lookUpSymbol(std::string symbolName);

    virtual ConstSymbolInfo *addNewConst(const std::string &name, int line, DataType dataType);

    virtual VarSymbolInfo *addNewVar(const std::string &name, int line, DataType dataType);

    virtual ConstArraySymbolInfo *
    addNewConstArray(const std::string &name, int line, DataType dataType, const std::vector<int> arraySize,
                     int dimension);

    virtual VarArraySymbolInfo *
    addNewVarArray(const std::string &name, int line, DataType dataType, const std::vector<int> arraySize,
                   int dimension);

    BlockInfo *addNewBlock();

    BlockInfo *addNewBlock(FuncSymbolInfo *belongTo);
    //两个addNewBlock，主要是看这个block是不是函数
    //如果说是一个函数，那么在new一个新块的时候，自然的这个函数的形参就要加到这个块的符号表里面去

    BlockInfo(BlockInfo *parentBlock);

    BlockInfo(BlockInfo *parentBlock, FuncSymbolInfo *belongTo, const std::vector<SymbolInfo *> &paramList);

    ~BlockInfo(){};
    //如果说是直接隶属于函数的块，则需要记录belongto,同时所有函数的形参都作为这个块的符号表而存在
};
```

funcsymbol与变量常量数组的symbol大体一致，会在其中存储函数的参数，方便后续对于函数IRFunc的构造；同时函数中还会维持一个blockInfo，作为这个函数最大的一个block；

blockInfo中通过addNewVar等函数来向其中添加变量；同时由于这里的block并不是IR中的基本块，还需要记录自己的父block是谁，因此有getParentBlock与addNewBlcok函数(向其中添加自己的子block)；这里的每一个block都是一个单独的作用域，当需要进行符号查找的时候，lookUpSymbol函数会从当前的block出发向上一层层查找，直到找到变量，通过这种方式来解决重名变量作用域的问题。

##### visitConstantInitValue()

```
std::any SemanticAnalyzer::visitConstantInitValue(CACTParser::ConstantInitValueContext *context) {
    bool zero_dim;
    bool single_dim;  // 确定这个数组的写法，是一维的写法还是多维的写法，由此确定是否需要向下递归

    // 这里有一点，对于嵌套括号的写法，一定要越过single_dim这一层

    /* clang-format off */
    zero_dim = (context->constantExpression() != nullptr) && context->arraySize.empty();
    single_dim = !zero_dim &&
                 (context->dimension >= 1) && (context->LeftBrace() != nullptr && context->RightBrace() != nullptr) &&
                 //确定是一个数组(对应左侧与右侧)(任何数组都可以采用一维的写法)
                 (context->dimension == context->arraySize.size()) &&                        //确定是第一层进入
                 (context->constantInitValue().empty() ||
                  context->constantInitValue().front()->constantExpression() != nullptr);
    //往下多看一层，如果发现已经是constExpression了那么就代表是一维数组(或者啥都没有就是一对大括号);
    /* clang-format on */

    int arraySize = 0;

    /******single_dim直接终止递归，否则往下递归******/
    if (zero_dim) {
        context->constantExpression()->dataType = context->dataType;
        this->visit(context->constantExpression());
        currentSymbol->setInitValue(context->constantExpression()->getText(),
                                    context->constantExpression()->dataType);
    } else if (single_dim) {
        // 遍历每一个一维元素，直接压栈即可
        arraySize = std::accumulate(context->arraySize.begin(), context->arraySize.end(), 1,
                                    std::multiplies<>());

        // 如果有元素，先尝试压栈
        if (!context->constantInitValue().empty()) {  // 这个vector中没有元素
            for (auto constantInitValue: context->constantInitValue()) {
                constantInitValue->dataType = context->dataType;
                constantInitValue->dimension = context->dimension;

                this->visit(constantInitValue);
            }
        }

        // 补零
        for (int i = currentSymbol->getinitValueArraySize(); i < arraySize; i++) {
            currentSymbol->setZero(context->dataType);
        }
    } else {
        int subArraySize = 0;
        int currentSize = 0;

        /******进行array的参数一致性检查******/
        // type MUST BE array

        /******constantExpression不为空已经到底，arraySize还没empty，真实的数组(相比arraySize)少了维度******/
        if (context->constantExpression() != nullptr) {
            ErrorHandler::printErrorContext(context, "less brace for InitValue");
            throw std::runtime_error("Semantic analysis failed at " + std::string(__FILE__) + ":" +
                                     std::to_string(__LINE__));
        }

        /******constantExpression为空还没到底，arraySize已经empty，真实的数组(相比arraySize)多了维度******/
        if (context->arraySize.empty()) {
            ErrorHandler::printErrorContext(context, "more brace for InitValue");
            throw std::runtime_error("Semantic analysis failed at " + std::string(__FILE__) + ":" +
                                     std::to_string(__LINE__));
        }

        /******constantInitValue数量得和这一层的array属性值相同******/
        /******如果是最下一层一维的，可以选择不相同然后补零*****/
        if ((context->arraySize.size() != 1) &&
            (context->constantInitValue().size() != context->arraySize.front())) {
            ErrorHandler::printErrorContext(context, "Error number for InitValue");
            throw std::runtime_error("Semantic analysis failed at " + std::string(__FILE__) + ":" +
                                     std::to_string(__LINE__));
        }

        /******计算arraySize和subArraySize******/
        arraySize = std::accumulate(context->arraySize.begin(), context->arraySize.end(), 1,
                                    std::multiplies<>());
        subArraySize = arraySize / context->arraySize.front();

        for (auto constantInitValue: context->constantInitValue()) {
            // 更新下一级的locals
            constantInitValue->dataType = context->dataType;
            for (auto i = context->arraySize.begin() + 1; i < context->arraySize.end(); ++i) {
                constantInitValue->arraySize.push_back(*i);
            }
            constantInitValue->dimension = context->dimension;
            this->visit(constantInitValue);

            // 上面已经访问了一个子数组，然后将所有的空缺部位全部填上0
            currentSize +=
                    subArraySize;  // 这里与上面参数一致性的第三个判断是对应的；当是一维的时候这里可以选择补零，其他情况均不考虑
            for (int i = currentSymbol->getinitValueArraySize(); i < currentSize; i++) {
                currentSymbol->setZero(context->dataType);
            }
        }
    }

    return {};
}
```

visitConstantInitValue()主要完成每一个const或var的初始赋值。根据维数判断是数组还是原始的变量或常量，并且最终将所有的数组在根据CACT语言规范补0后变成一维数组。

如果是常量或变量，并且判断zero_dim为true，符合语义规范，则直接setInitValue，将初始值设置为其IRValue；

如果是数组，根据CACT语言规范。要么采取直接将多维数组转变为一维数组写入的形式，要么根据维数嵌套大括号。如果符合这两种规范其一，则语义检查通过；如果嵌套大括号中间有空，则采取添0来进行处理。在符合语义规范的情况下，通过setInitValue来对数组赋初值。

##### visitVariableDeclaration()

```
std::any SemanticAnalyzer::visitVariableDefinition(CACTParser::VariableDefinitionContext *context) {
    size_t line = context->Identifier()->getSymbol()->getLine();
    for (auto size: context->IntegerConstant()) {
        context->arraySize.push_back(stoi(size->getText()));
    }
    size_t dimension = context->arraySize.size();
    std::string name = context->Identifier()->getText();
    /******先构建玩currentsymbol，再去往下访问******/
    if (dimension == 0) {
        currentSymbol = this->currentBlock->addNewVar(name, line, context->dataType);
    } else {
        currentSymbol = this->currentBlock->addNewVarArray(name, line, context->dataType,
                                                           context->arraySize, dimension);
    }

    if (context->constantInitValue() != nullptr) {
        context->constantInitValue()->dataType = context->dataType;
        context->constantInitValue()->arraySize = context->arraySize;
        context->constantInitValue()->dimension = dimension;  // 这里必须得传进维数，确定递归层数
        this->visit(context->constantInitValue());
    } else {
        /*如果没有显式初始化，那么通过一个循环把所有相关初始化为0的数全部压进去*/
        unsigned loop;
        if (context->arraySize.empty()) {
            loop = 1;
        } else {
            loop = std::accumulate(context->arraySize.begin(), context->arraySize.end(), 1,
                                   std::multiplies());
        }

        for (int i = 0; i < loop; i++) {
            currentSymbol->setZero(context->dataType);  // 如果没有显式初始化
        }
    }
    // return std::make_tuple(name, context->arraySize, dimension, line);

	...
}
```

visitVariableDeclaration()负责对于变量在进入initValue赋初值之前进行维数等判断的预处理。首先函数会根据是变量还是变量数组构建一个符号，然后将这个符号传进visitinitValue()函数来进行构建，

同时在符号构建完毕后还会根据将当前的符号加入对应block的符号表中，方便后续的作用域检查；设置变量的irinitValueArray方便后面的IRValue的赋初值。

##### visitFunctionDefinition()

```
std::any SemanticAnalyzer::visitFunctionDefinition(CACTParser::FunctionDefinitionContext *context) {
    std::string returnTypeText = context->functionType()->getText();
    DataType returnType;
    returnType = Utils::stot(returnTypeText);

    context->thisfuncinfo =
            globalBlock->addNewFunc(context->Identifier()->getText(),
                                    context->Identifier()->getSymbol()->getLine(), returnType);
    // 全局块中的函数表添加，同时获得这个funcdefinition的funcsymbolinfo，为将来的blockinfo初始化做准备

    currentFunc = context->thisfuncinfo;  // 更新currentFunc
    /******先构建一个basicblock,后续对他的parent进行赋值******/
    IRBasicBlock *irfirstbasicblock;
    irfirstbasicblock = new IRBasicBlock("0");

    /******构建了paramlist,IRArgs(缺少母函数)，IRparams******/
    if (context->functionFParams() != nullptr) {
        if (context->Identifier()->getText() == std::string("main")) {
            ErrorHandler::printErrorContext(
                    context,
                    "main function must be without params");  // main函数不能带有参数
            throw std::runtime_error("Semantic analysis failed at " + std::string(__FILE__) + ":" +
                                     std::to_string(__LINE__));
        } else {
            context->functionFParams()->thisfuncinfo = context->thisfuncinfo;
            context->functionFParams()->irbasicblock = irfirstbasicblock;
            this->visit(
                    context
                            ->functionFParams());  // 先去访问参数，在将参数都访问完之后可以获得一个完整的函数定义，再去定义blockinfo
            // 等待下面的参数层完善这个函数
        }
    }

    ...

    return {nullptr};
}
```

visitFunctionDefinition()在语义检查的过程中主要负责检查是否为main函数(如果为main则不能有参数)，以及如果函数返回类型不为void，是否有返回值。在满足上述语义规范的情况下，在函数表中添加该函数，并且给每个块设置母函数。

##### visitFunctionFParam()

```
std::any SemanticAnalyzer::visitFunctionFParam(CACTParser::FunctionFParamContext *context) {
    std::string basicTypeText = context->basicType()->getText();
    DataType basicType;
    basicType = Utils::stot(basicTypeText);
    SymbolInfo *symbolInfo;
    IRArgument *irarg;
    IRType *irElType;
    IRType *irType;

    int dimension;
    dimension = context->LeftBracket().size();  // 计算维数

    switch (basicType) {
        case BOOL:
            irElType = const_cast<IRType *>(IRType::getPrimitiveType(IRType::BoolTyID));
            break;
        case INT:
            irElType = const_cast<IRType *>(IRType::getPrimitiveType(IRType::IntTyID));
            break;
        case FLOAT:
            irElType = const_cast<IRType *>(IRType::getPrimitiveType(IRType::FloatTyID));
            break;
        case DOUBLE:
            irElType = const_cast<IRType *>(IRType::getPrimitiveType(IRType::DoubleTyID));
            break;
    }

    /******new一个basicblock往里面添加******/

    if (!dimension) {
        symbolInfo = context->thisfuncinfo->addParamVar(
                context->Identifier()->getText(), context->Identifier()->getSymbol()->getLine(),
                basicType);

        irType = irElType;
        // 变量设置IRValue
        // dynamic_cast<VarSymbolInfo*>(symbolInfo)->setIRValue(IRValue::InstructionVal, basicType,
        //                                        context->beforeFuncCount, context->irbasicblock);
    } else {
        int valid_size;  // 标记了数字的个数//第一维可能标记为0
        valid_size = context->IntegerConstant().size();
        std::vector<int> param_array;

        if (valid_size == dimension) {
            for (auto integetconstant: context->IntegerConstant()) {
                param_array.push_back(stoi(integetconstant->getText()));
            }
        } else if (valid_size == (dimension - 1)) {
            /******如果第一维是空的话那么给0******/
            param_array.push_back(0);
            for (auto integetconstant: context->IntegerConstant()) {
                param_array.push_back(stoi(integetconstant->getText()));
            }
        } else {
            ErrorHandler::printErrorContext(context, "array dimension error");
            throw std::runtime_error("Semantic analysis failed at " + std::string(__FILE__) + ":" +
                                     std::to_string(__LINE__));
        }  // 分析得到paramlist

        symbolInfo = context->thisfuncinfo->addParamArray(
                context->Identifier()->getText(), context->Identifier()->getSymbol()->getLine(),
                basicType, param_array, dimension);

        //unsigned arraysize;  // 记录这个paramarray有多大
        //arraysize = std::accumulate(param_array.begin(), param_array.end(), 1, std::multiplies());
        irType = new IRPointerType(irElType);

        // 变量设置IRValue
        // dynamic_cast<VarArraySymbolInfo*>(symbolInfo)->setIRValue(IRValue::InstructionVal,
        // basicType,
        //                                                 context->beforeFuncCount,
        //                                                 context->irbasicblock);
    }

    /******与paramlist同步构建IRargs与IRparams******/
    irarg = new IRArgument(irType, std::to_string(context->beforeFuncCount));
    currentFunc->getIRArgs().push_back(irarg);
    currentFunc->getIRParams().push_back(irType);
    /******将新加入参数的类型加入到当前函数中******/
    // currentFunc->getIRParams().push_back(symbolInfo->getIRValue()->getType());

    return {nullptr};
}
```

在函数参数的语义检查中，最重要的部分在于如果传参是数组需要考虑维数是否正确，同时通过paramlist的构建获得该函数的参数列表，见函数的参数列表计入这个函数对应的block的符号表中；同时同步构建IRargs与IRparams，在将来的任务中通过参数列表来构建函数的IRFunc。

#### 2.IR类生成

IR类的生成主要分为两个部分：第一部分是关于变量常量数组，以及函数对应IR类的生成，第二部分是关于由这些IR类构造出的指令类的生成

##### 变量常量对应IR类的生成

```
void VarSymbolInfo::setIRValue(IRValue::ValueTy vTy, unsigned SymbolCount, IRBasicBlock* parent, IRValue* IRinitializer, IRModule* irmodule){

    /******对一个var而言,所有显式和非显式的初始化全部都在外面做好之后压到initvaluearray里面******/
    if(!initValueArray.empty()){
        irinitializer = initValueArray[0];
    }else{
        irinitializer = IRinitializer;
    }
    assert(irinitializer);

    switch (vTy) {
        case IRValue::GlobalVariableVal :
            irValue = new IRGlobalVariable  
                (irinitializer->getType(), false, IRGlobalValue::InternalLinkage,
                 dynamic_cast<IRConstant*>(irinitializer), 
                 this->getName(), irmodule);
            break;

        case IRValue::InstructionVal :
            irValue = new IRAllocaInst 
                (irinitializer->getType(), nullptr, this->getName()+std::to_string(SymbolCount), parent);
            break;
    }
}
```

变量IR的生成首先需要对是全局变量还是局部变量进行区分。如果是全局变量则生成的IR类需要是GlobalVariableVal，否则对应是InstructionVall。同时对于每一个变量，在CACT语言规范中都需要对其赋初值，这就要求了在visit函数中已经将初值写进irinitValueArray中，或者将初值通过IRinitializer传入。

根据全局变量和局部变量的判断，会相应的new一个IRGlobalVariable或IRAllocInst类，并且将IRValue类加入到当前basicblock块中的Instlist或者IRModule的中。

##### 函数对应IR类的生成

```
void FuncSymbolInfo::setIRValue(IRModule* irModule, IRFunction::FuncTy functy){

    /******通过这个类自己的属性Result来构建IR需要的Result******/
    const IRType *IRResult;
    switch (returnType) {
        case VOID:
            IRResult = IRType::getPrimitiveType(IRType::VoidTyID);
            break;
        case BOOL:
            IRResult = IRType::getPrimitiveType(IRType::BoolTyID);
            break;
        case INT:
            IRResult = IRType::getPrimitiveType(IRType::IntTyID);
            break;
        case FLOAT:
            IRResult = IRType::getPrimitiveType(IRType::FloatTyID);
            break;
        case DOUBLE:
            IRResult = IRType::getPrimitiveType(IRType::DoubleTyID);
            break;
    }

    irValue = new IRFunction(new IRFunctionType(const_cast<IRType *>(IRResult), IRParams), IRGlobalValue::InternalLinkage, 
                            this->getName(), irModule, functy);
    /******将已经分配出的参数个数算进去******/

    /******arg与函数的双向奔赴******/
    for(auto arg :getIRArgs()){
        arg->setParent(dynamic_cast<IRFunction*>(irValue));
        dynamic_cast<IRFunction*>(irValue)->addArgument(arg);
    }

    dynamic_cast<IRFunction*>(irValue)->setCount(IRArgs.size()+1);
}
```

在这个setIRValue中，实现了函数的IRValue类的生成。在生成IRFunc之前，已经将所需要的参数压进了IRargs中(后面需要用参数来判断函数的类型)，同时在这个函数中将每个参数的母函数建立起来

##### 外层visit对于setIRValue函数的调用

```
/******先构建一个basicblock,后续对他的parent进行赋值******/
    IRBasicBlock *irfirstbasicblock;
    irfirstbasicblock = new IRBasicBlock("0");

    /******构建了paramlist,IRArgs(缺少母函数)，IRparams******/
    if (context->functionFParams() != nullptr) {
        if (context->Identifier()->getText() == std::string("main")) {
            ErrorHandler::printErrorContext(
                    context,
                    "main function must be without params");  // main函数不能带有参数
            throw std::runtime_error("Semantic analysis failed at " + std::string(__FILE__) + ":" +
                                     std::to_string(__LINE__));
        } else {
            context->functionFParams()->thisfuncinfo = context->thisfuncinfo;
            context->functionFParams()->irbasicblock = irfirstbasicblock;
            this->visit(
                    context
                            ->functionFParams());  // 先去访问参数，在将参数都访问完之后可以获得一个完整的函数定义，再去定义blockinfo
            // 等待下面的参数层完善这个函数
        }
    }

    /******构建函数,设置basicblock
     * parent,设置irCurrentFunc的basicblocklist,setIRValue中构建IRargs的母函数******/
    currentFunc->setIRValue(ir, IRFunction::Declared);
    irfirstbasicblock->setParent(dynamic_cast<IRFunction *>(currentFunc->getIRValue()));
    dynamic_cast<IRFunction *>(currentFunc->getIRValue())->addBasicBlock(irfirstbasicblock);

    /******从每个函数的(paramList)symbol出发，构建每个symbol的IRValue******/
    for (size_t i = 0; i < currentFunc->getparamList().size(); i++) {
        SymbolInfo *symbol;
        IRValue *arg;
        symbol = currentFunc->getparamList()[i];
        arg = currentFunc->getIRArgs()[i];

        if (dynamic_cast<VarArraySymbolInfo *>(symbol)) {
            dynamic_cast<VarArraySymbolInfo *>(symbol)->setIRValue(
                    IRValue::InstructionVal,
                    dynamic_cast<IRFunction *>(currentFunc->getIRValue())->getCount(),
                    irfirstbasicblock, arg);
        } else if (dynamic_cast<VarSymbolInfo *>(symbol)) {
            dynamic_cast<VarSymbolInfo *>(symbol)->setIRValue(
                    IRValue::InstructionVal,
                    dynamic_cast<IRFunction *>(currentFunc->getIRValue())->getCount(),
                    irfirstbasicblock, arg);
        }
        new IRStoreInst(dynamic_cast<ConstVarArraySymbolInfo *>(symbol)->getirInitailizer(), symbol->getIRValue(),
                        irfirstbasicblock);

        dynamic_cast<IRFunction *>(currentFunc->getIRValue())->addCount();
    }

    context->compoundStatement()->thisfuncinfo = context->thisfuncinfo;
```

构建函数的IRFunc的主要步骤如上：

1. 根据对函数每个参数visit进行访问，构建出函数的IRparams，IRargs，为后续的函数IRFunc生成做准备；
2. 构建函数并设置好IRbasicblock，在后续的生成中，需要将函数参数的值store到该函数内部变量对应的地址中，因此需要basicblock来指定生成的store指令的存放位置；在我们的设计里，并不是直接用这些参数来作为变量；
3. 在函数中，对于每一个参数都会new一个与之相对应的IRValue。这些IRValue的值都是地址，然后将函数参数的值store到这些IRValue对应的地址中；

```
/******在访问完下面的definition之后根据他们的不同类型进行setIRValue******/
    // 有一个疑问对于每一个symbol而言，有要求他们的basicblock必须是第一个吗？
    /******如果是global的，那么不需要进行currentFunc的getIRValue******/
    IRFunction *irCurrentFunc;
    if (dimension == 0) {
        if (currentBlock != globalBlock) {  // var instruction
            irCurrentFunc = dynamic_cast<IRFunction *>(currentFunc->getIRValue());
            dynamic_cast<VarSymbolInfo *>(currentSymbol)
                    ->setIRValue(IRValue::InstructionVal, irCurrentFunc->getCount(),
                                 irCurrentFunc->getBasicBlockList()[0]);
            irCurrentFunc->addCount();
        } else  // var externaldeclaration
            dynamic_cast<VarSymbolInfo *>(currentSymbol)
                    ->setIRValue(IRValue::GlobalVariableVal, 0, nullptr, nullptr, ir);
    } else {
        if (currentBlock != globalBlock) {  // vararray instruction
            irCurrentFunc = dynamic_cast<IRFunction *>(currentFunc->getIRValue());
            dynamic_cast<VarArraySymbolInfo *>(currentSymbol)
                    ->setIRValue(IRValue::InstructionVal, irCurrentFunc->getCount(),
                                 irCurrentFunc->getBasicBlockList()[0], nullptr, ir);
            irCurrentFunc->addCount();
        } else  // vararray externaldeclaration
            dynamic_cast<VarArraySymbolInfo *>(currentSymbol)
                    ->setIRValue(IRValue::GlobalVariableVal, 0, nullptr, nullptr, ir);
    }
```

在外层的visit中，当碰到variableDefinition时，会在访问完毕得到symbol的所有信息之后，根据variable的类型，即全局还是函数内，是变量还是变量数组来调用不同类的setIRValue函数，并且传递不同的参数。

#### IR代码的生成

IR代码的生成首先是了解IR的一些基本类之间的继承等关系，其次是通过这些IR类中的print函数来打印出最终的IR代码

##### IRGlobalValue,IRGlobalVariable,IRFunction

```
class IRGlobalValue : public IRUser {
protected:
    IRGlobalValue(IRType *Ty, ValueTy vty, LinkageTypes linkage,
                  const std::string &name = "")
        : IRUser(Ty, vty, name), Linkage(linkage), Parent(nullptr) {}
    LinkageTypes Linkage;
    IRModule *Parent;

public:
    ~IRGlobalValue() = default;

    /******注意这里的强制转换类型，对于IRGlobalValue，全部将type类型强制转换为pointertype******/
    inline IRPointerType *getType() const {
        return (IRPointerType *) IRUser::getType();
    }
    /******提供一个不强制转换类型的函数******/
    inline IRType *getOriginType() const {
        return IRUser::getType();
    }

	...

    /******获得最大块******/
    inline IRModule *getParent() { return Parent; }

};

class IRGlobalVariable : public IRGlobalValue {
    void setParent(IRModule *parent);

    bool isConstantGlobal;

public:
    IRGlobalVariable(IRType *Ty, bool isConstant, LinkageTypes Linkage,
                     IRConstant *Initializer = nullptr, const std::string &Name = "",
                     IRModule *Parent = nullptr);

    /******全局变量的初始化******/
    inline bool hasInitializer() const { return !Operands.empty(); }
    inline IRConstant *getInitializer() const {
        assert(hasInitializer() && "GV doesn't have initializer!");
        return (IRConstant *) Operands[0].get();
    }
    inline void setInitializer(IRConstant *CPV) {
        if (CPV == nullptr) {
            if (hasInitializer()) Operands.pop_back();
        } else {
            if (!hasInitializer()) Operands.emplace_back(nullptr, this);
            Operands[0] = (IRValue *) CPV;
        }
    }

    /******判断是不是一个常量，但是我们都会把这个常量直接当作立即数使用，故无用******/
    bool isConstant() const { return isConstantGlobal; }

    /******全局变量的print******/
    void printPrefixName(std::ostream &OS) const;
    void print(std::ostream &OS) const override;

};

class IRFunction : public IRGlobalValue {
public:
    enum FuncTy{
        Declared,
        UnDeclared,
    };

private:
    std::vector<IRArgument *> ArgumentList;
    std::vector<IRBasicBlock *> BasicBlocks;
    IRModule *Parent;
    unsigned IRSymbolCount = 0;
    FuncTy fTy;

    void setParent(IRModule *parent);

public:
    IRFunction(IRFunctionType *Ty, IRGlobalValue::LinkageTypes Linkage, 
            const std::string &N, IRModule *M, FuncTy fty);
    ~IRFunction() = default;

//    const IRType *getReturnType() const;            // Return the type of the ret val
    const FuncTy  getFuntTy() { return fTy; };

    /******IRFunction继承IRvalue，获得它的IRtype指针******/
    IRFunctionType *getFunctionType() const;        // Return the FunctionType for me

    /******函数的arg和basicblock******/
    std::vector<IRArgument *> &getArgumentList() { return ArgumentList; }
    std::vector<IRBasicBlock *> &getBasicBlockList() { return BasicBlocks; }

    void addArgument(IRArgument * arg);
    void addBasicBlock(IRBasicBlock * block);

    IRBasicBlock *getEntryBlock() { return BasicBlocks.front(); }

    /******IRFunction的print方法******/
    void printPrefixName(std::ostream &OS) const override;
    void Funcprint(std::ostream &OS) const;
    void print(std::ostream &OS) const override;

    /******每一个函数维护自己这个函数内记录了多少个IRSymbol******/
    void addCount(){ IRSymbolCount++; }
    unsigned getCount(){ return IRSymbolCount; }
    void setCount(unsigned Count){ IRSymbolCount = Count; }
};

```

IRGlobalVariable与IRFunction都继承了IRGlobalValue类，作为全局的的变量或者函数

* IRGlobalValue类提供了一个getParent()接口，由于IRGlobalVariable与IRFunction都是全局的，因此可以通过他们直接获得全局的IRModule；
* IRGlobalVariable类由于是全局变量，因此提供了initializer相关函数来对这些全局变量进行初始化；
* IRFunction类在内部维护了函数参数列表和Basicblock列表，每一个函数在经过语义分析之后，会将其中的控制流语句全部摊平成一个个的basicblock，IRFunction提供了访问这些基本块的接口；同时IRFunction内部拥有print相关的函数来进行打印最终生成的IR代码；IRFunction内部还维护了一个count变量，用来最终生成IR代码中的变量进行命名。

##### IRType类

```
class IRType : public IRValue {
public:
    enum PrimitiveID {
        VoidTyID = 0,
        BoolTyID,//  0, 1: Basics...
        IntTyID, //  2: 32 bit types...
        FloatTyID,
        DoubleTyID,// 3, 4: Floating point types...

        TypeTyID, // 5   : Type definitions
        LabelTyID,// 6   : Labels...

        // Derived types... see DerivedTypes.h file...
        FunctionTyID,
        ArrayTyID,
        PointerTyID,

        NumPrimitiveIDs,// Must remain as last defined ID
        FirstDerivedTyID = FunctionTyID,
    };

private:
    PrimitiveID ID;

protected:
    IRType(const std::string &Name, IRType::PrimitiveID id);

    ~IRType() override = default;

public:
    void print(std::ostream &OS) const override;

    inline PrimitiveID getPrimitiveID() const { return ID; }

    /**
     * Return true if the value is holdable in a register
     * @return bool
     */
    inline bool isFirstClassType() const {
        return isPrimitiveType() || ID == PointerTyID;
    }

    /**
     *
     * @return basic size of this type if it is a primitive type, zero if the type
     * dose not have a size or is not a primitive type
     */
    unsigned getPrimitiveSize() const;

    static const IRType *getPrimitiveType(PrimitiveID IDNumber);

    static IRType *VoidTy, *BoolTy;
    static IRType *IntTy;
    static IRType *FloatTy, *DoubleTy;

    static IRType *TypeTy, *LabelTy;
};

class IRSequentialType : public IRType {
protected:
    IRType *elementType;
    IRSequentialType(PrimitiveID TID, IRType *ElType)
        : IRType("", TID) {
        elementType = ElType;
    }

public:
    inline IRType *getElementType() const { return elementType; }
    virtual const IRType *getTypeAtIndex(const IRValue *V) const {
        return elementType;
    }
    virtual bool indexValid(const IRValue *V) const {
        return V->getType() == IRType::IntTy;// Must be a 'int' index
    }
    virtual const IRType *getIndexType() const { return IRType::IntTy; }

    void IRpointerPrintAlign(std::ostream &OS);
};
```

IRType是代码框架中一个较为巧妙的实现，下面用较大的篇幅来对其进行介绍：

* 在每一个IRValue类中都会维护一个IRType类来表明这个IRValue的类型，如IRFunctionType；但是对于多重指针的情况，单纯的只用一个IRType自然不能表示出所有可能的指针情况，因此在IRSequentialType中有一个getElementType函数来间接地达到指针类型的效果；
* 如果当前的IRValue只是单纯的函数类型或者bool，int类型等，那么IRType将是简单的primitiveType类型；否则将属于DerivedType；在IRType类中有专门的getPrimitiveID等一系列函数来判断是否属于primitiveType；
* 如果是DerivedType类型，进一步的是指针类型或者数组类型，那么在SequentialType中将提供getElementType函数来进行多层嵌套，即每一层getElementType会返回当前指针所指向的类型(或数组中包含的元素类型)，最终获得底层的primitiveType类型；
* 在IRType中由于底层的primitiveType类型是一个会被多次复用的类，因此将其做成了静态的对象放在了IRType类中，每次不用new一个新的对象，直接返回静态对象的指针即可。

## 总结

### 实验结果总结

#### 1.demo运行结果

![alt text](image.png)

如图所示，compiler成功运行，并报出了00号测试用例在语法分析过程中的错误

#### 2.测试样例运行结果

运行syntax_test.sh脚本，依次在各个样例上运行compiler

![alt text](image-1.png)
如图所示，成功通过了所有测试样例

在syntax_test.sh的第13行前增加一行代码：

```bash
        echo $ans
```

可以在测试过程中打印出每个测试用例解析的结果

![alt text](image-2.png)

我们人工对比一下标准答案，发现确实是正确的

### 分成员总结

苑骏康：本次实验中，我负责实验报告的撰写，在撰写实验报告的过程中，我对于ANTLR工具的功能和使用方式有了更全面的了解，对实验设计思路进行了总结，掌握了前端词法分析和语法分析的整个流程，理解了各个项目文件在整个系统中发挥的作用，同时学习了EBNF规范，掌握了语法描述文件的编写方式。在汪铭煜同学的帮助下，我搭建了ANTLR环境，成功运行了项目，同时对CLion和git等工具的使用也更加熟练了。

汪铭煜：本次实验中，我参与了g4和源代码的编写。我参考了antlr/grammars-v4仓库中的C语言的例子来编写我们自己的g4。在编写代码的过程中对于ANTLR工具有了更深的了解，特别是通过单步跟踪阅读ANTLR生成的visitor，使我对于抽象语法树有了更深的认识。同时我还编写测试脚本、修改 CmakeLists.txt 使得在 vscode 和 Clion 这些工具的帮助下可以对项目进行一键编译和一键测试，提高了开发效率。

盛子轩：本次实验中，我参与了g4代码的编写与检查。在antlr/grammars-v4仓库g4的基础上，我又根据CACT自身的一些特性做了修改，并且参与了由g4生成的代码的debug。在debug跟踪调试的过程中，我更加清晰的认识了antlr4的运行环境，自动生成语法树的访问以及根据文法进行语法分析最基本的步骤。通过对g4文件的学习，我掌握了最基本的文法编写规范，也对正则的表达式规范有了一个初步的了解

### 参考文献

Adaptive LL(*) Parsing: The Power of Dynamic Analy[https://www.antlr.org/papers/allstar-techreport.pdf]

ANTLR 4简明教程[https://www.bookstack.cn/read/antlr4-short-course/]

LL(*)的概念与实现[http://pfmiles.github.io/blog/concept-and-implementation-of-ll-star/]

C.g4[https://github.com/antlr/grammars-v4/tree/master/c]
